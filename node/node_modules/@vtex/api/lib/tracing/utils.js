"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_error_report_1 = require("@vtex/node-error-report");
function getTraceInfo(span) {
    var _a, _b, _c;
    const spanContext = span.context();
    return {
        isSampled: (_c = (_b = (_a = spanContext).isSampled) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : false,
        traceId: spanContext.toTraceId(),
    };
}
exports.getTraceInfo = getTraceInfo;
/**
 * Do a shallow copy of a headers object and redacts sensitive information.
 *
 * @param headersObj The headers object
 * @param resultFieldsPrefix The prefix that will be added to each field on the result object
 */
exports.cloneAndSanitizeHeaders = (headersObj, resultFieldsPrefix = '') => {
    const ret = {};
    const entries = Object.entries(headersObj);
    for (const [key, val] of entries) {
        // Most of the time val is a string, but there are some cases, for example when we do a axios interceptor,
        // that a header field can contain an object, for example:
        // ```
        // "common": {
        //   "Accept": "application/json, text/plain, */*"
        // },
        // "delete": { },
        // "get": { },
        // "head": { },
        // "post": {
        //   "Content-Type": "application/x-www-form-urlencoded"
        // },
        // ```
        // In those corner cases we probably won't have a sensitive string as key, so we don't treat them here
        ret[`${resultFieldsPrefix}${key}`] = node_error_report_1.authFields.includes(key) ? node_error_report_1.sanitizeAuth(val) : val;
    }
    return ret;
};
