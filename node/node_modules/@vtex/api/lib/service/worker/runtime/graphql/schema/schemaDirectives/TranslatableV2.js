"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const translations_1 = require("../../utils/translations");
const messagesLoaderV2_1 = require("../messagesLoaderV2");
class TranslatableV2 extends graphql_tools_1.SchemaDirectiveVisitor {
    visitFieldDefinition(field) {
        const { resolve = graphql_1.defaultFieldResolver } = field;
        const { behavior = 'FULL', withAppsMetaInfo = false } = this.args;
        field.resolve = async (root, args, ctx, info) => {
            var _a;
            if (!((_a = ctx.loaders) === null || _a === void 0 ? void 0 : _a.messagesV2)) {
                const { vtex: { locale: to } } = ctx;
                if (to == null) {
                    throw new Error('@translatableV2 directive needs the locale variable available in IOContext. You can do this by either setting \`ctx.vtex.locale\` directly or calling this app with \`x-vtex-locale\` header');
                }
                const dependencies = withAppsMetaInfo ? await ctx.clients.apps.getAppsMetaInfos() : undefined;
                ctx.loaders = {
                    ...ctx.loaders,
                    messagesV2: messagesLoaderV2_1.createMessagesLoader(ctx.clients, to, dependencies),
                };
            }
            const response = await resolve(root, args, ctx, info);
            const { vtex, loaders: { messagesV2 } } = ctx;
            const handler = translations_1.handleSingleString(vtex, messagesV2, behavior, 'translatableV2');
            return Array.isArray(response)
                ? Promise.all(response.map(handler))
                : handler(response);
        };
    }
}
exports.TranslatableV2 = TranslatableV2;
exports.translatableV2DirectiveTypeDefs = `
directive @translatableV2(
  behavior: String
  withAppsMetaInfo: Boolean
) on FIELD_DEFINITION
`;
